/*
PrivMX Endpoint.
Copyright Â© 2024 Simplito sp. z o.o.

This file is part of the PrivMX Platform (https://privmx.dev).
This software is Licensed under the PrivMX Free License.

See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef _PRIVMXLIB_ENDPOINT_PRIVMXCLI_VARS_FUN_HELP_HPP_
#define _PRIVMXLIB_ENDPOINT_PRIVMXCLI_VARS_FUN_HELP_HPP_


#include <string>
#include <unordered_map>
#include "privmx/endpoint/programs/privmxcli/vars/function_enum.hpp"
inline const std::unordered_map<func_enum, std::string> functions_internal_help_description = {
    {quit, "quit"},
    {falias, "falias NEW_ALIAS FUNCTION_NAME \n\t Function  alias"},
    {salias, "alias NEW_ALIAS, VAR_NAME \n\t Var alias"},
    {scopy, "copy NEW_VAR, VAR_NAME \n\t Var copy"},
    {sset, "set VAR_NAME, VAR_VALUE \n\t Set new var"},
    // {ssetArray, "setArray ARRAY_NAME VAR_VALUE ..."},
    {sget, "get VAR_NAME"},
    {sreadFile, "setFromFile VAR_NAME path"},
    {swriteFile, "saveToFile VAR_NAME path"},
    {help, "help FUNCTION_NAME \n\t also you can use ? afer function name to get help"},
    {loopStart, "loopStart N OPTIONAL<ID> \n\t  loops everything N times to loopStop \n\t  Id is optional"},
    {loopStop, "loopStop"},
    {a_sleep, "sleep T \n\t sleep for T ms \nsleep(T1,T2) \n\t sleep for random time between T1 T2ms"},
    {addFront, "addFront VAR_NAME_1 VAR_NAME_2) \n\tadd second var on the front of the first var"},
    {addBack, "addBack VAR_NAME_1 VAR_NAME_2 \n\tadd second var on the back of the first var"},
    {addFrontString, "addFront VAR_NAME, DATA_STRING) \n\tadd DATA_STRING on the front of var"},
    {addBackString, "addBack VAR_NAME, DATA_STRING) \n\tadd DATA_STRING on the back of var"}
};

inline const std::unordered_map<func_enum, std::string> functions_internal_help_short_description = {
    {quit, "quit"},
    {falias, "create function alias"},
    {salias, "create var alias"},
    {scopy, "copy var"},
    {sset, "Set new var"},
    // {ssetArray, "setArray ARRAY_NAME VAR_VALUE ..."},
    {sget, "gets var"},
    {sreadFile, "reads from file"},
    {swriteFile, "write to file"},
    {help, "help"},
    {loopStart, "marker to start loop"},
    {loopStop, "marker to stop loop"},
    {a_sleep, "sleep for"},
    {addFront, "add var on the front of the other"},
    {addBack, "add var on the back of the other"},
    {addFrontString, "add string on the front of var"},
    {addBackString, "add string on the front of var"}
};

inline const std::unordered_map<func_enum, std::string> functions_help_description = {
    //endpoint
    {waitEvent, "waitEvent JSON_ARRAY \n\t json format - []\n\t always run in new thread (works only in -i mode)"},
    {getEvent, "getEvent JSON_ARRAY \n\t json format - []"},
    {platformConnect, "platformConnect JSON_ARRAY \n\t json format - [userPrivKey, solutionId, platformUrl]\n\t\tuserPrivKey [STRING] - user's private key\n\t\tsolutionId [STRING] - id of solution\n\t\tplatformUrl [STRING] - platform's endpoint url"},
    {platformDisconnect, "platformDisconnect JSON_ARRAY \n\t json format - []"},
    {contextList, "contextList JSON_ARRAY \n\t json format - [skip, limit, sortOrder]\n\t\tskip [NUMBER] - skip n first records on result list\n\t\tlimit [NUMBER] - limits result's length to given value\n\t\tsortOrder [STRING] - sort result descanding (value: 'desc'), orascending (value: 'asc')"},
    {threadCreate, "threadCreate JSON_ARRAY \n\t json format - [contextId, users:[{userId, pubKey}], managers[{userId, pubKey}], title]\n\t\tcontextId [STRING] - id of context to create thread in\n\t\tusers [JSON] - vector of UserWithPubKey structs which indicates who will have access to created thread\n\t\tmanagers [JSON] - vector of UserWithPubKey structs which indicates who will have access (and have manage rights) to created thread\n\t\ttitle [STRING] - title of newly crated thread"},
    {threadGet, "threadGet JSON_ARRAY \n\t json format - [threadId]\n\t\tthreadId [STRING] - id of thread to get"},
    {threadList, "threadList JSON_ARRAY \n\t json format - [contextId, skip, limit, sortOrder]\n\t\tcontextId [STRING] - id of context to get threads from\n\t\tskip [NUMBER] - skip n first records on result list\n\t\tlimit [NUMBER] - limits result's length to given value\n\t\tsortOrder [STRING] - sort result descanding (value: \"desc\"), or ascending (value: \"asc\")"},
    {threadMessageSend, "threadMessageSend JSON_ARRAY \n\t json format - [threadId, clientMsgId, clientUserId, mimetype, text]\n\t\tthreadId [STRING] - id of the thread to send message to\n\t\tclientMsgId [STRING] - message id (defined by developer)\n\t\tclientUserId [STRING] - user id (defined by developer)\n\t\tmimetype [STRING] - message's mime type\n\t\ttext [STRING] - actual message"},
    {threadMessagesGet, "threadMessagesGet JSON_ARRAY \n\t json format - [threadId, skip, limit, sortOrder]\n\t\threadId [STRING] - id of thread to read message from\n\t\tskip [NUMBER] - skip n first records on result list\n\t\tlimit [NUMBER] - limits result's length to given value\n\t\tsortOrder [STRING] - sort result descanding (value: \"desc\"), orascending (value: \"desc\")"},
    {storeList, "storeList JSON_ARRAY \n\t json format - [contextId, skip, limit, sortOrder]\n\t\tcontextId [STRING] - id of context to get stores from\n\t\tskip [NUMBER] - skip n first records on result list\n\t\tlimit [NUMBER] - limits result's length to given value\n\t\tsortOrder [STRING] - sort result descanding (value: \"desc\"), or ascending (value: \"desc\")"},
    {storeGet, "storeGet JSON_ARRAY \n\t json format - [storeId]\n\t\tstoreId [STRING] - id of store to get"},
    {storeCreate, "storeCreate JSON_ARRAY \n\t json format - [contextId, users:[{userId, pubKey}], managers:[{userId, pubKey}], title]\n\t\tcontextId [STRING] - id of context to create store in\n\t\tusers [JSON] - vector of UserWithPubKey structs which indicates who will have access to created thread\n\t\tmanagers [JSON] - vector of UserWithPubKey structs which indicates who will have access (and have manage rights) to created thread\n\t\ttitle [STRING] - title of newly crated store"},
    {storeFileGet, "storeFileGet JSON_ARRAY \n\t json format - [fileId]\n\t\tstoreId - id of file to get"},
    {storeFileList, "storeFileList JSON_ARRAY \n\t json format - [storeId, skip, limit, sortOrder]\n\t\tstoreId [STRING] - id of store to get files from\n\t\tskip [NUMBER] - skip n first records on result list\n\t\tlimit [NUMBER] - limits result's length to given value\n\t\tsortOrder [STRING] - sort result descanding (value: \"desc\"), or ascending (value: \"desc\")"},
    {storeFileCreate, "storeFileCreate JSON_ARRAY \n\t json format - [storeId, size, mimetype, name]\n\t\tstoreId [STRING] - id of store to create file in\n\t\tsize [NUMBER] - size of data to write\n\t\tmimetype [STRING] - mimetype of file\n\t\tname [STRING] - name of file"},
    {storeFileUpdate, "storeFileUpdate JSON_ARRAY \n\t json format - [fileId, size, mimetype, name]\n\t\tfileId [STRING] - id of file to update\n\t\tsize [NUMBER] - size of data to write\n\t\tmimetype [STRING] - mimetype of file\n\t\tname [STRING] - name of file"},
    {storeFileOpen, "storeFileOpen JSON_ARRAY \n\t json format - [fileId]\n\t\tfileId [STRING] - id of file to read"},
    {storeFileRead, "storeFileRead JSON_ARRAY \n\t json format - [handle, length]\n\t\thandle [NUMBER] - handle to file data\n\t\tlength [NUMBER] - size of data to read"},
    {storeFileWrite, "storeFileWrite JSON_ARRAY \n\t json format - [handle, dataChunk]\n\t\thandle [NUMBER] - handle to file data\n\t\tdataChunk [STRING] - file data chunk"},
    {storeFileSeek, "storeFileSeek JSON_ARRAY \n\t json format - [handle, pos]\n\t\thandle [NUMBER] - handle to file data\n\t\tpos [NUMBER] - new cursor position"},
    {storeFileClose, "storeFileClose JSON_ARRAY \n\t json format - [handle]\n\t\thandle [NUMBER] - handle to file data"},
    {storeFileDelete, "storeFileDelete JSON_ARRAY \n\t json format - [fileId]\n\t\tfileId - id of file to delete"},
    {cryptoPrivKeyNew, "cryptoPrivKeyNew JSON_ARRAY \n\t json format - [optional<basestring>]\n\t\tasestring [STRING] - optional string used as base in process of generating the key"},
    {cryptoPubKeyNew, "cryptoPubKeyNew JSON_ARRAY \n\t json format - [privkey]\n\t\tprivkey [STRING] - private ECC key in WIF format"},
    {cryptoEncrypt, "cryptoEncrypt JSON_ARRAY \n\t json format - [data, key]\n\t\tdata [STRING] - buffer to encrypt\n\t\tkey [STRING] - used to encrypt data"},
    {cryptoDecrypt, "cryptoDecrypt JSON_ARRAY \n\t json format - [data, key]\n\t\tdata [STRING] - buffer to decrypt\n\t\tkey [STRING] - used to decrypt data"},
    {cryptoSign, "cryptoSign JSON_ARRAY \n\t json format - [data, key]\n\t\tdata [STRING] - buffer to sign\n\t\tkey [STRING] - used to sign data"},
    {setCertsPath, "setCertsPath JSON_ARRAY \n\t json format - [certsPath] \n\t\tcertsPath [STRING] - filesystem's path to certs file"},
    {cryptoKeyConvertPEMToWIF, "cryptoKeyConvertPEMToWIF JSON_ARRAY \n\t json format - [keyPEM] \n\t\tkeyPEM [STRING] - private key in PEM format"},
    {backendRequest, "backendRequest JSON_ARRAY \n\t json format - [cloudServerUrl, memberToken, method, paramsJson] \n\t\tcloudServerUrl [STRING] - server's URL \n\t\tmemberToken [STRING] - member access token to server's API\n\t\tmethod [STRING] - request method\n\t\tparamsJson [STRING] - request method params (in JSON format)"},
    {threadDelete, "threadDelete JSON_ARRAY \n\t json format - [threadId]\n\t\tthreadId [STRING] - id of thread to delete"},
    {threadMessageDelete, "threadMessageDelete JSON_ARRAY \n\t json format - [messageId]\t\n\nmessageId [STRING] - id of message to delete"},
    {threadMessageGet, "threadMessageGet JSON_ARRAY \n\t json format - [messageId]\t\n\nmessageId [STRING] - id of message to get"},
    {storeDelete, "storeDelete JSON_ARRAY \n\t json format - [storeId]\t\n\nstoreId [STRING] - id of store to delete"},
    {messageGet, "messageGet JSON_ARRAY \n\t json format - [messageId]"},
    {messagesGet, "messagesGet JSON_ARRAY \n\t json format - [threadId, skip, limit, sortOrder]"},
    {messageSend, "messageSend JSON_ARRAY \n\t json format - [threadId, publicMeta, privateMeta, data]"},
    {inboxCreate, "inboxCreate JSON_ARRAY \n\t json format - [contextId, users:[{userId, pubKey}], managers:[{userId, pubKey}], meta, options?]"},
    {inboxUpdate, "inboxUpdate JSON_ARRAY \n\t json format - [inboxId, users:[{userId, pubKey}], managers:[{userId, pubKey}], newMeta, newOptions, version, force, generateNewKey]"},
    {inboxGet, "inboxGet JSON_ARRAY \n\t json format - [inboxId]"},
    {inboxList, "inboxList JSON_ARRAY \n\t json format - [contextId, skip, limit, sortOrder]"},
    {inboxPublicViewGet, "inboxPublicViewGet JSON_ARRAY \n\t json format - [inboxId]"},
    {inboxCreateFileHandle, "inboxCreateFileHandle JSON_ARRAY \n\t json format - [fileSize, mimetype, name]"},
    {inboxSendPrepare, "inboxSendPrepare JSON_ARRAY \n\t json format - [inboxId, data, inboxFileHandles?, userPrivKey?]"},
    {inboxSendFileDataChunk, "inboxSendFileDataChunk JSON_ARRAY \n\t json format - [inboxHandle, inboxFileHandle, dataChunk]"},
    {inboxSendCommit, "inboxSendCommit JSON_ARRAY \n\t json format - [inboxHandle]"},
    {threadUpdate, "threadUpdate JSON_ARRAY \n\t json format - [threadId, users:[{userId, pubKey}], managers:[{userId, pubKey}], title, version, force, generateNewKey]\n\t\tthreadId [STRING] - id of thread to update\n\t\tusers [JSON] - vector of UserWithPubKey structs which indicates who will have access to created thread\n\t\tmanagers [JSON] - vector of UserWithPubKey structs which indicates who will have access (and have manage rights) to created thread\n\t\tname [STRING] - title of thread\n\t\tversion [NUMBER] - version of thread being updated\n\t\tforce [BOOL] - force update (without checking version)\n\t\tgenerateNewKey [BOOL] - force to regenerate keyId for thread"},
    {storeUpdate, "storeUpdate JSON_ARRAY \n\t json format - [storeId, users:[{userId, pubKey}], managers:[{userId, pubKey}], name, version, force, generateNewKey]\n\t\tstoreId [STRING] - id of store to update.\n\t\tusers [JSON] - vector of UserWithPubKey structs which indicates who will have access to created thread\n\t\tmanagers [JSON] - vector of UserWithPubKey structs which indicates who will have access (and have manage rights) to created thread\n\t\tname [STRING] - title of store\n\t\tversion [NUMBER] - version of store being updated\n\t\tforce [BOOL] - force update (without checking version)\n\t\tgenerateNewKey - force to renenerate keyId for store"},
    {cryptoKeyConvertPEMToWIF, "cryptoKeyConvertPEMToWIF JSON_ARRAY \n\t json format - [password, salt]\t\n\npassword [STRING] - to generate key from\t\n\nsalt [STRING]"},
    {subscribeToChannel, "subscribeToChannel JSON_ARRAY \n\t json format - [channel]"},
    {unsubscribeFromChannel, "unsubscribeFromChannel JSON_ARRAY \n\t json format - [channel]"},
    {fileGet, "fileGet JSON_ARRAY \n\t json format - [fileId]"},
    {fileList, "fileList JSON_ARRAY \n\t json format - [storeId, skip, limit, sortOrder]"},
    {fileOpen, "fileOpen JSON_ARRAY \n\t json format - [fileId]"},
    {fileSeek, "fileSeek JSON_ARRAY \n\t json format - [handle, pos]"},
    {fileRead, "fileRead JSON_ARRAY \n\t json format - [handle, length]"},
    {fileClose, "fileClose JSON_ARRAY \n\t json format - [handle]"},
    {inboxFileGet, "inboxFileGet JSON_ARRAY \n\t json format - [fileId]"},
    {inboxFileList, "inboxFileList JSON_ARRAY \n\t json format - [storeId, skip, limit, sortOrder]"},
    {inboxFileOpen, "inboxFileOpen JSON_ARRAY \n\t json format - [fileId]"},
    {inboxFileSeek, "inboxFileSeek JSON_ARRAY \n\t json format - [handle, pos]"},
    {inboxFileRead, "inboxFileRead JSON_ARRAY \n\t json format - [handle, length]"},
    {inboxFileClose, "inboxFileClose JSON_ARRAY \n\t json format - [handle]"},
    {inboxMessageGet, "inboxMessageGet JSON_ARRAY \n\t json format - [messageId]"},
    {inboxMessagesGet, "inboxMessagesGet JSON_ARRAY \n\t json format - [threadId, skip, limit, sortOrder]"},
    {messageDelete, "messageDelete JSON_ARRAY \n\t json format - [messageId]"},
    {inboxDelete, "inboxDelete JSON_ARRAY \n\t json format - [inboxId]"}
};

inline const std::unordered_map<func_enum, std::string> functions_help_short_description = {
    //endpoint
    {waitEvent, ""},
    {getEvent, ""},
    {platformConnect, "Connects to the platform backend."},
    {platformDisconnect, "Disconnects from the platform backed."},
    {contextList, "Get list of context"},
    {threadCreate, "Create new thread in the context."},
    {threadGet, "Get thread by threadId given."},
    {threadList, "Get list of threads in context given."},
    {threadMessageSend, "Send message in a thread. [DEPRECATED]"},
    {threadMessagesGet, "Get messages from thread. [DEPRECATED]"},
    {storeList, "Get list of stores in context given."},
    {storeGet, "Get single store by store id given."},
    {storeCreate, "Create new store in the context given."},
    {storeFileGet, "Get single file by file id given."},
    {storeFileList, "Get list of files in store given."},
    {storeFileCreate, "Create new file in store."},
    {storeFileUpdate, "Update existing file in store."},
    {storeFileOpen, "Open file to read."},
    {storeFileRead, "Read file data. If read data size is less than @p lenght , then end of file. Recommened @p length is 131072."},
    {storeFileWrite, "Write file data. Recommened size of data chunk is 131072."},
    {storeFileSeek, "Move read cursor."},
    {storeFileClose, "Close file handle."},
    {storeFileDelete, "Delete file by id given."},
    {cryptoPrivKeyNew, "Generates crypto private ECC key."},
    {cryptoPubKeyNew, "Generates crypto public ECC key."},
    {cryptoEncrypt, "Encrypt buffer with a given key using AES."},
    {cryptoDecrypt, "Decrypt buffer with a given key using AES."},
    {cryptoSign, "Create signature of data and key given."},
    {setCertsPath, "Sets path to .pem file with certificates."},
    {cryptoKeyConvertPEMToWIF, "Converts private key given in PEM format to its WIF format."},
    {backendRequest, "Lets create requests to PrivMX Cloud Server API."},
    {threadDelete, "Delete thread by threadId given."},
    {threadMessageDelete, "Delete message by messageId given."},
    {threadMessageGet, "Get message by messageId given. [DEPRECATED]"},
    {storeDelete, "Delete store by store id given."},
    {messageGet, ""},
    {messagesGet, ""},
    {messageSend, ""},
    {inboxCreate, ""},
    {inboxUpdate, ""},
    {inboxGet, ""},
    {inboxList, ""},
    {inboxPublicViewGet, ""},
    {inboxCreateFileHandle, ""},
    {inboxSendPrepare, ""},
    {inboxSendFileDataChunk, ""},
    {inboxSendCommit, ""},
    {threadUpdate, "Update existing Thread."},
    {storeUpdate, "Update existing Store."},
    {cryptoKeyConvertPEMToWIF, "Generates crypto private ECC key from password using pbkdf2."},
    {subscribeToChannel, ""},
    {unsubscribeFromChannel, ""},
    {fileGet, ""},
    {fileList, ""},
    {fileOpen, ""},
    {fileSeek, ""},
    {fileRead, ""},
    {fileClose, ""},
    {inboxFileGet, ""},
    {inboxFileList, ""},
    {inboxFileOpen, ""},
    {inboxFileSeek, ""},
    {inboxFileRead, ""},
    {inboxFileClose, ""},
    {inboxMessageGet, ""},
    {inboxMessagesGet, ""},
    {messageDelete, ""},
    {inboxDelete, ""}
};


inline const std::unordered_map<func_enum, std::string> functions_action_description = {
    //endpoint
    {waitEvent, "waiting for event"},
    {getEvent, "getting event"},
    {platformConnect, "platform connecting"},
    {platformDisconnect, "platform disconnecting"},
    {contextList, "getting contexts"},
    {threadCreate, "creating thread"},
    {threadGet, "getting thread"},
    {threadList, "getting threads"},
    {threadMessageSend, "sending thread message"},
    {threadMessagesGet, "getting thread messages"},
    {storeList, "getting stores"},
    {storeGet, "getting store"},
    {storeCreate, "creating store"},
    {storeFileGet, "getting store file"},
    {storeFileList, "listing store file"},
    {storeFileCreate, "creating store file"},
    {storeFileOpen, "opening store file"},
    {storeFileRead, "reading store file"},
    {storeFileWrite, "writing store file"},
    {storeFileSeek, "seeking store file"},
    {storeFileClose, "closing store file"},
    {storeFileDelete, "deleting store file"},
    {cryptoPrivKeyNew, "Running cryptoPrivKeyNew"},
    {cryptoPubKeyNew, "Running cryptoPubKeyNew"},
    {cryptoEncrypt, "Running cryptoEncrypt"},
    {cryptoDecrypt, "Running cryptoDecrypt"},
    {cryptoSign, "Running cryptoSign"},
    {setCertsPath, "setting CertsPath"},
    {cryptoKeyConvertPEMToWIF, "Running cryptoKeyConvertPEMToWIF"},
    {backendRequest, "Running backendRequest"},
    {threadDelete, "deleting thread"},
    {threadMessageDelete, "deleting thread message"},
    {threadMessageGet, "getting thread message"},
    {storeDelete, "store deleting"},
    {messageGet, "message getting"},
    {messagesGet, "messages getting"},
    {messageSend, "message sending"},
    {inboxCreate, "creating inbox"},
    {inboxUpdate, "updating inbox"},
    {inboxGet, "getting inbox"},
    {inboxList, "getting inboxes"},
    {inboxPublicViewGet, "getting inbox public view"},
    {inboxCreateFileHandle, "creating inbox file handle"},
    {inboxSendPrepare, "prepare inbox for data send"},
    {inboxSendFileDataChunk, "sending inbox file data chunk"},
    {inboxSendCommit, "committing inbox send data"},
    {threadUpdate, "updating thread"},
    {storeUpdate, "updating store"},
    {cryptoKeyConvertPEMToWIF, "Running cryptoPrivKeyNewPbkdf2"},
    {subscribeToChannel, "subscribing to channel"},
    {unsubscribeFromChannel, "unsubscribing from channel"},
    {fileGet, "getting file meta"},
    {fileList, "listing files meta"},
    {fileOpen, "opening file"},
    {fileSeek, "seeking file"},
    {fileRead, "reading file"},
    {fileClose, "closing file"},
    {inboxFileGet, "getting inbox file meta"},
    {inboxFileList, "listing inbox files meta"},
    {inboxFileOpen, "opening inbox file"},
    {inboxFileSeek, "seeking inbox file"},
    {inboxFileRead, "reading inbox file"},
    {inboxFileClose, "closing inbox file"},
    {inboxMessageGet, "getting inbox message"},
    {inboxMessagesGet, "getting inbox messages"},
    {messageDelete, "deleting message and related to it data"},
    {inboxDelete, "deleting inbox and related to it data"}
};

#endif // _PRIVMXLIB_ENDPOINT_PRIVMXCLI_VARS_FUN_HELP_HPP_